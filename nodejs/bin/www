#!/usr/bin/env node

/**
 * Module dependencies.
 */
require('dotenv').config();
var app = require('../app');
var debug = require('debug')('nodejs:server');
var http = require('http');
const WebSocket = require('ws');
const db = require('../database/mysql2');
let binanceWs = {};
const url = require('url');
const cron = require('node-cron');
/*
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.WEBSOCKET_PORT || '8386');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
const wss = new WebSocket.Server({ server });

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

const clients = new Map();

function addToMap(map, key, value) {
  if (!map.has(key)) {
    map.set(key, []);
  }
  map.get(key).push(value);
}

// Hàm tạo kết nối Binance WebSocket
const createBinanceConnection = (symbols, ws, query) => {
  // Sử dụng endpoint đúng cho Binance WebSocket (không còn dùng /ws, mà dùng /stream?streams=...)
  // Xây dựng chuỗi streams cho nhiều symbol
  let streams = [];
  if (Array.isArray(symbols)) {
    streams = symbols.map(symbol => symbol.toLowerCase() + '@ticker');
  } else {
    streams = [symbols.toLowerCase() + '@ticker'];
  }
  const streamString = streams.join('/');
  const binanceWsUrl = `wss://stream.binance.com:9443/stream?streams=${streamString}`;
  let binanceWs;
  try {
    binanceWs = new WebSocket(binanceWsUrl);
  } catch (err) {
    console.error('Không thể kết nối Binance WebSocket:', err);
    return { binanceWs: null, binanceDepthWs: null };
  }

  let binanceDepthWs = null;
  if (query.depth === 'true') {
    let depthStreams = [];
    if (Array.isArray(symbols)) {
      depthStreams = symbols.map(symbol => symbol.toLowerCase() + '@depth');
    } else {
      depthStreams = [symbols.toLowerCase() + '@depth'];
    }
    const depthStreamString = depthStreams.join('/');
    const binanceDepthWsUrl = `wss://stream.binance.com:9443/stream?streams=${depthStreamString}`;
    try {
      binanceDepthWs = new WebSocket(binanceDepthWsUrl);
    } catch (err) {
      console.error('Không thể kết nối Binance Depth WebSocket:', err);
      binanceDepthWs = null;
    }
  }

  const setupBinanceWs = (ws) => {
    ws.on('open', () => {
      // Không cần gửi SUBSCRIBE khi dùng endpoint /stream?streams=...
      // console.log('Đã kết nối Binance WebSocket:', ws.url);
    });

    ws.on('close', (code, reason) => {
      console.log('Binance WebSocket đóng, đang kết nối lại...', code, reason && reason.toString());
      setTimeout(() => {
        // Kết nối lại với cùng URL
        setupBinanceWs(new WebSocket(ws.url));
      }, 5000);
    });

    ws.on('error', (error) => {
      if (error && error.message && error.message.includes('403')) {
        console.error('Binance WebSocket bị từ chối (403 Forbidden). Vui lòng kiểm tra endpoint hoặc giới hạn kết nối.');
      } else {
        console.error('Binance WebSocket error:', error);
      }
      ws.close();
    });

    return ws;
  };

  const setupBinanceDepthWs = (ws) => {
    if (!ws) return null;

    ws.on('open', () => {
      // Không cần gửi SUBSCRIBE khi dùng endpoint /stream?streams=...
      // console.log('Đã kết nối Binance Depth WebSocket:', ws.url);
    });

    ws.on('close', (code, reason) => {
      // setTimeout(() => {
      //   setupBinanceDepthWs(new WebSocket(ws.url));
      // }, 5000);
    });

    ws.on('error', (error) => {
      if (error && error.message && error.message.includes('403')) {
        console.error('Binance Depth WebSocket bị từ chối (403 Forbidden). Vui lòng kiểm tra endpoint hoặc giới hạn kết nối.');
      } else {
        console.error('Binance Depth WebSocket error:', error);
      }
      ws.close();
    });

    return ws;
  };

  const binanceWsSetup = setupBinanceWs(binanceWs);
  const binanceDepthWsSetup = setupBinanceDepthWs(binanceDepthWs);

  return { binanceWs: binanceWsSetup, binanceDepthWs: binanceDepthWsSetup };
};

wss.on('connection', async (ws, req) => {
  const query = url.parse(req.url, true).query;
  let binanceConnections = null;

  // Handle Binance WebSocket connections
  if (query.symbols) {
    let symbols;
    try {
      symbols = JSON.parse(query.symbols);
    } catch (e) {
      symbols = query.symbols;
    }
    binanceConnections = createBinanceConnection(symbols, ws, query);
    const { binanceWs, binanceDepthWs } = binanceConnections;

    if (binanceWs) {
      binanceWs.on('message', (data) => {
        let parsedData;
        try {
          parsedData = JSON.parse(data);
        } catch (e) {
          // Có thể là buffer, bỏ qua
          return;
        }
        // Dữ liệu trả về từ endpoint /stream?streams=... sẽ có dạng { stream, data }
        if (parsedData.data && parsedData.data.s) {
          const symbol = parsedData.data.s;
          const price = parseFloat(parsedData.data.c);
          const priceChange = parseFloat(parsedData.data.P);
          const volume = parseFloat(parsedData.data.v);
          const high = parseFloat(parsedData.data.h);
          const low = parseFloat(parsedData.data.l);
          const volumeUsdt = parseFloat(parsedData.data.q);
          ws.send(JSON.stringify({
            type: 'marketData',
            symbol: symbol,
            data: parsedData.data,
            data1: {
              price: price,
              priceChange: priceChange,
              volume: volume,
              high: high,
              low: low,
              volumeUsdt: volumeUsdt,
              symbol: symbol
            },
          }));
        }
      });
    }

    if (binanceDepthWs) {
      binanceDepthWs.on('message', (data) => {
        try {
          const parsedData = JSON.parse(data);
          if (parsedData.data && parsedData.data.s) {
            ws.send(JSON.stringify({
              type: 'depthData',
              symbol: parsedData.data.s,
              data: parsedData.data
            }));
          }
        } catch (error) {
          console.error('Error processing depth data:', error);
        }
      });
    }
  }

  ws.on('message', (data) => {
    const parsedData = JSON.parse(data);
    if(parsedData.type === 'subscribe_trades') {
      if(parsedData.user_id) {
        addToMap(clients, parsedData.user_id, ws);
      }
    }
  });

  // Xử lý khi client ngắt kết nối
  ws.on('close', () => {
    // Xóa client khỏi Map
    // for (const [userId, client] of clients.entries()) {
    //   if (client === ws) {
    //     clients.delete(userId);
    //     break;
    //   }
    // }

    // Đóng kết nối Binance nếu có
    if (binanceConnections) {
      if (binanceConnections.binanceWs) {
        binanceConnections.binanceWs.close();
      }
      if (binanceConnections.binanceDepthWs) {
        binanceConnections.binanceDepthWs.close();
      }
    }
  });

  // Xử lý lỗi kết nối
  ws.on('error', (error) => {
    console.error('Client WebSocket error:', error);
  });
});

const reward = async () => {
  const [user_trades] = await db.query(`SELECT * FROM user_trades WHERE trade_end < NOW() AND status = 'pending'`);
  for(const user_trade of user_trades) {
    const [user] = await db.query(`SELECT * FROM users WHERE id = ?`, [user_trade.user_id]);
    const [time_session] = await db.query(`SELECT * FROM time_sessions WHERE id = ?`, [user_trade.session_id]);
    const [symbol] = await db.query(`SELECT * FROM symbols WHERE id = ?`, [user_trade.symbol_id]);
    let win_rate = time_session[0].win_rate;
    let lose_rate = time_session[0].lose_rate;
    let balance = user[0].balance;
    let profit = user_trade.profit;

    if(user_trade.result === 'win') {
      profit = user_trade.amount * win_rate / 100;
      balance += user_trade.amount + profit;
    } else {
      profit = user_trade.amount * lose_rate / 100;
      balance += user_trade.amount - profit;
    }

    await db.query(`UPDATE users SET balance = ? WHERE id = ?`, [balance, user_trade.user_id]);
    let period = time_session[0].time;
    if(time_session[0].unit === 'm') {
      period = time_session[0].time * 60;
    } else if(time_session[0].unit === 'h') {
      period = time_session[0].time * 3600;
    } else if(time_session[0].unit === 'd') {
      period = time_session[0].time * 86400;
    }
    const clientSockets = clients.get(user_trade.user_id);

    for(const clientSocket of clientSockets) {
      if(clientSocket) {
        clientSocket.send(JSON.stringify({
          type: 'reward',
          period: period,
          entry_type: parseFloat(user_trade.open_price) > parseFloat(user_trade.close_price) ? 'buy' : 'sell',
          amount: user_trade.amount,
          status: user_trade.result,
          profit: profit,
          balance: balance,
          current_price: user_trade.close_price,
          order_type: user_trade.type,
          symbol: symbol[0].symbol,
          open_price: user_trade.open_price,
        }));
      }
      
    }

    await db.query(`UPDATE user_trades SET status = 'success' where id = ?`, [user_trade.id]);
  }
}

cron.schedule('*/1 * * * * *', reward);
function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
// setInterval(() => {
//   const mem = process.memoryUsage();
//   const rssMB = (mem.rss / 1024 / 1024).toFixed(2);
//   const heapTotalMB = (mem.heapTotal / 1024 / 1024).toFixed(2);
//   const heapUsedMB = (mem.heapUsed / 1024 / 1024).toFixed(2);
//   const externalMB = (mem.external / 1024 / 1024).toFixed(2);
//   const socketCount = clients.size;
  

//   console.log('================ MEMORY USAGE ================');
//   console.log(`RSS: ${rssMB} MB`);
//   console.log(`Heap Total: ${heapTotalMB} MB`);
//   console.log(`Heap Used: ${heapUsedMB} MB`);
//   console.log(`External: ${externalMB} MB`);
//   console.log(`Số lượng socket đang mở: ${socketCount}`);
//   // user online
//   for(const [userId, client] of clients.entries()) {
//     console.log(`User ID: ${userId} is online`);
//   }
//   console.log('==============================================');
// }, 30000); // mỗi 30 giây log một lần
